using UnityEngine;
using System.Collections;
using System.Collections.Generic;
using System;

using Util;

// TODO we need a GetPoint(float t) method, either directly in a path
// or as a separate utility. For pure bezier paths it would be easy to implement,
// but for polyline or composite paths it woudl need some more effort by
// implementing a smart smoothing / interpolating algorithm. One possiblity would
// be to convert polyline path to bezier path on-the-fly.


namespace Paths
{
	public delegate void PathChangedEventHandler (object sender,EventArgs e);

	public class PathGizmoPrefs
	{
		public static readonly Color ControlPointConnectionLineColor = Color.gray;
		public static readonly Color ControlPointMarkerColor = Color.gray;
		public static readonly Color FinalPathLineColor = Color.cyan;
		public static readonly Color FinalPathPointMarkerColor = Color.cyan;
		public static readonly Color FinalPathFirstPointMarkerColor = Color.yellow;
		public static readonly Color UpVectorColor = new Color (0.1f, 1f, 0.1f);
		public static readonly Color DirVectorColor = new Color (0.1f, 0.1f, 1f);
		public static readonly Color RightVectorColor = new Color (1f, 0.1f, 0.1f);
		public static readonly float UpVectorLength = 1.0f;
		public static readonly float DirVectorLength = 1.0f;
		public static readonly float RightVectorLength = 1.0f;
		public static readonly float FinalPathPointMarkerSize = 0.05f;
		public static readonly float FinalPathFirstPointMarkerSize = 0.1f;
	}

	// TODO we don't really need the IPath interface since we're always referring to Path
	// (which is a GameObject)
//  public interface IPath
//  {
//      bool IsLoop ();
//
//  }



	public abstract class PathDataInputSource
	{

		public enum SourceType
		{
			/// <summary>
			/// Empty input data (the path data is generated by path modifiers).
			/// </summary>
			None,

			/// <summary>
			/// Input data from control points (typically user defined)
			/// </summary>
			Self,

			/// <summary>
			/// Input data from another data set in this or another path.
			/// </summary>
			DataSet,
		}
		private SourceType type;
		protected PathDataInputSource (SourceType type)
		{
			this.type = type;
		}
		public SourceType GetSourceType ()
		{
			return type;
		}
	}
	public sealed class PathDataInputSourceNone : PathDataInputSource
	{
		public static readonly PathDataInputSourceNone Instance = new PathDataInputSourceNone ();

		private PathDataInputSourceNone () : base(SourceType.None)
		{
		}
	}
	public sealed class PathDataInputSourceSelf : PathDataInputSource
	{
		public static readonly PathDataInputSourceSelf Instance = new PathDataInputSourceSelf ();
		
		private PathDataInputSourceSelf () : base(SourceType.Self)
		{
		}
	}

	[Serializable]
	public class PathDataInputSourceDataSet : PathDataInputSource
	{
		[SerializeField]
		private int
			dataSetId;

		[SerializeField]
		private bool
			fromSnapshot;

		[SerializeField]
		private string
			snapshotName;

		[SerializeField]
		private bool
			sourcePathIsSelf = true;

		[SerializeField]
		private bool
			sourcePathIsParent = false;

		[SerializeField]
		private Path
			sourcePath;

		public PathDataInputSourceDataSet () : base(SourceType.DataSet)
		{

		}

		public PathDataInputSourceDataSet (bool sourcePathIsSelf, bool sourcePathIsParent, Path sourcePath, int dataSetId, bool fromSnapshot, string snapshotName)
			: this()
		{
			this.sourcePathIsSelf = sourcePathIsSelf;
			this.sourcePathIsParent = sourcePathIsParent;
			this.sourcePath = sourcePath;

			this.dataSetId = dataSetId;
			this.fromSnapshot = fromSnapshot;
			this.snapshotName = snapshotName;
		}
	

		public bool IsSourcePathSelf ()
		{
			return sourcePathIsSelf;
		}
		public bool IsSourcePathParent ()
		{
			return sourcePathIsParent;
		}
		public Path GetSourcePath ()
		{
			return sourcePath;
		}

		public int GetDataSetId ()
		{
			return dataSetId;
		}
		public bool IsFromSnapshot ()
		{
			return fromSnapshot;
		}
		public string GetSnapshotName ()
		{
			return snapshotName;
		}


		
		public PathDataInputSourceDataSet WithSourcePathIsSelf (bool value)
		{
			return new PathDataInputSourceDataSet (value, sourcePathIsParent, sourcePath, dataSetId, fromSnapshot, snapshotName);
		}
		public PathDataInputSourceDataSet WithSourcePathIsParent (bool value)
		{
			return new PathDataInputSourceDataSet (sourcePathIsSelf, value, sourcePath, dataSetId, fromSnapshot, snapshotName);
		}

		public PathDataInputSourceDataSet WithSourcePath (Path value)
		{
			return new PathDataInputSourceDataSet (sourcePathIsSelf, sourcePathIsParent, value, dataSetId, fromSnapshot, snapshotName);
		}

		public PathDataInputSourceDataSet WithDataSetId (int value)
		{
			return new PathDataInputSourceDataSet (sourcePathIsSelf, sourcePathIsParent, sourcePath, value, fromSnapshot, snapshotName);
		}
		public PathDataInputSourceDataSet WithFromSnapshot (bool value)
		{
			return new PathDataInputSourceDataSet (sourcePathIsSelf, sourcePathIsParent, sourcePath, dataSetId, value, snapshotName);
		}
		public PathDataInputSourceDataSet WithSnapshotName (string value)
		{
			return new PathDataInputSourceDataSet (sourcePathIsSelf, sourcePathIsParent, sourcePath, dataSetId, fromSnapshot, value);
		}

	}


	// TODO Should this be renamed to AbstractPath?
	public abstract class Path : MonoBehaviour, ISerializationCallbackReceiver, IReferenceContainer
	{
		public event PathChangedEventHandler Changed;

		public enum PathStatus
		{
			Dynamic,
			ManualRefresh,
			Frozen
		}

		// TODO move this to PathData??? Maybe not
		private static readonly Color[] DefaultDataSetColors = new Color[]{
			Color.cyan,
			Color.yellow,
			Color.white,
			Color.magenta,
			Color.grey,
		};




		[SerializeField]
		private ParameterStore
			parameterStore = new Util.ParameterStore ();


		[SerializeField]
		private PathStatus
			frozenStatus = PathStatus.Dynamic;

		[SerializeField]
		private List<UnityEngine.Object>
			referents = new List<UnityEngine.Object> ();

//		[SerializeField]
//		private List<IPathData>
//			dataSets = new List<IPathData> ();

		[SerializeField]
		private int
			defaultDataSetId;

		[SerializeField]
		private int
			nextDataSetId = 1;

		[SerializeField]
		private int
			nextDataSetColorIndex = 0;

		private IPathInfo pathInfo;

		public Path ()
		{
			// TODO add Reset() method!
			IPathData defaultData = AddDataSet ();
			SetDataSetName (defaultData, "Default");

			nextDataSetColorIndex = 0;


			frozenStatus = PathStatus.Dynamic;
//			pathPointsDirty = true;
		}

		//protected abstract List<IPathData> GetDataSets ();
//		protected abstract int GetDataSetCount ();



		public static Path FindParentPathObject (Transform obj)
		{
			Transform parent = obj.parent;
			if (null != parent) {
				Path path = parent.GetComponent<Path> ();
				if (null != path) {
					return path;
				} else {
					return FindParentPathObject (parent);
				}
			} else {
				return null;
			}
		}

		private int NextDataSetId ()
		{
			return nextDataSetId++;
		}
		private Color NextDataSetColor ()
		{
			if (nextDataSetColorIndex >= DefaultDataSetColors.Length) {
				nextDataSetColorIndex = 0;
			}
			return DefaultDataSetColors [nextDataSetColorIndex++];

		}


		public int GetDefaultDataSetId ()
		{
			//return Mathf.Clamp (this.defaultDataSetIndex, -1, dataSets.Count - 1);
			return this.defaultDataSetId;
		}
		public void SetDefaultDataSetId (int id)
		{
			IPathData d = FindDataSetById (id);
			if (null != d) {
				this.defaultDataSetId = d.GetId ();
			}
		}
		// TODO move Set... methods to PathData itself? 
		public bool IsDefaultDataSet (IPathData data)
		{
			return null != data && data.GetId () == GetDefaultDataSetId ();
		}



		public abstract int GetDataSetCount ();
		public abstract IPathData GetDataSetAtIndex (int index);
		protected abstract void DoInsertDataSet (int index, IPathData data);
		protected abstract void DoRemoveDataSet (int index);

		public IPathData GetDefaultDataSet ()
		{
			return FindDataSetById (GetDefaultDataSetId ());
		}

		public int IndexOfDataSet (IPathData data)
		{
			int dsCount = GetDataSetCount ();

			int index = -1;
			int idToFind = data.GetId ();
			for (int i = 0; i < dsCount; i++) {
				IPathData ds = GetDataSetAtIndex (i);
				if (ds.GetId () == idToFind) {
					index = i;
					break;
				}
			}
			return index;
		}
		public virtual bool IsSetDataSetIndexSupported ()
		{
			return false;
		}
		public virtual void SetDataSetIndex (IPathData data, int newIndex)
		{
		}


		public IPathData FindDataSetById (int id)
		{
			int dsCount = GetDataSetCount ();
			// TODO add lookup dictionary (we also need to listen to name changes!)
			for (int i = 0; i < dsCount; i++) {
				IPathData data = GetDataSetAtIndex (i);
				if (data.GetId () == id) {
					return data;
				}
			}
			return null;
		}
		public IPathData FindDataSetByName (string name)
		{
			int dsCount = GetDataSetCount ();
			// TODO add lookup dictionary (we also need to listen to name changes!)
			for (int i = 0; i < dsCount; i++) {
				IPathData data = GetDataSetAtIndex (i);
				if (data.GetName () == name) {
					return data;
				}
			}
			return null;
		}

		protected abstract IPathData CreatePathData (int id);

		private void AttachPathData (IPathData data)
		{
			if (data is IAttachableToPath) {
				try {
					((IAttachableToPath)data).AttachToPath (this);
				} catch (Exception e) {
					Debug.LogError ("An exception occurred while invoking PathData.AttachToPath: " + e, this);
				}
			}
			try {
				OnAttachPathData (data);
			} catch (Exception e) {
				Debug.LogError ("An exception occurred while invoking OnAttachPathData(): " + e, this);
			}
		}
		protected void OnAttachPathData (IPathData data)
		{

		}
		private void DetachPathData (IPathData data)
		{
			if (data is IAttachableToPath) {
				try {
					((IAttachableToPath)data).DetachFromPath (this);
				} catch (Exception e) {
					Debug.LogError ("An exception occurred while invoking PathData.DetachFromPath: " + e, this);
				}
			}
			try {
				OnDetachPathData (data);
			} catch (Exception e) {
				Debug.LogError ("An exception occurred while invoking OnDetachPathData(): " + e, this);
			}
		}
		protected void OnDetachPathData (IPathData data)
		{
			
		}


		public IPathData AddDataSet ()
		{
			return InsertDataSet (GetDataSetCount ());
		}
		public IPathData InsertDataSet (int index)
		{
			int dsCount = GetDataSetCount ();
			IPathData data = CreatePathData (NextDataSetId ());
			if (dsCount == 0) {
				// First data set, i.e. the default
				this.defaultDataSetId = data.GetId ();
			}
			data.SetColor (NextDataSetColor ());
			DoInsertDataSet (index, data);

			AttachPathData (data);

			//			if (index < GetDefaultDataSetIndex ()) {
			//				// Update the default data set index
			//				this.defaultDataSetIndex++;
			//			}
			return data;
		}
		public void RemoveDataSetAtIndex (int index)
		{
			IPathData dataToRemove = GetDataSetAtIndex (index);
			if (dataToRemove.GetId () == GetDefaultDataSetId ()) {
				throw new ArgumentException ("Can't remove default Data Set");
			}

			DoRemoveDataSet (index);

			DetachPathData (dataToRemove);
			

		}

		public void SetDataSetName (IPathData data, string name)
		{
			if (data is AbstractPathData) {
				((AbstractPathData)data).SetName (StringUtil.Trim (name, true));
				// TODO update name lookup index!
			} else {
				throw new ArgumentException ("Renaming PathData of type '" + data.GetType ().FullName + "' is not supported");
			}
		}
//		public void SetDataSetColor (IPathData data, Color value)
//		{
//			if (data is AbstractPathData) {
//				((PathDataImpl)data).SetColor (value);
//				// TODO update name lookup index!
//			} else {
//				throw new ArgumentException ("Renaming PathData of type '" + data.GetType ().FullName + "' is not supported");
//			}
//		}

		public void SetDataSetInputSourceType (IPathData data, PathDataInputSource.SourceType sourceType)
		{
			((AbstractPathData)data).SetInputSourceType (sourceType);
		}
		public T SetDataSetInputSource<T> (IPathData data, T source) where T: PathDataInputSource
		{
			((AbstractPathData)data).SetInputSource (source);
			return (T)((AbstractPathData)data).GetInputSource ();
		}
//		public void SetDataSetInputSourceType(PathData data, PathDataInputSource.SourceType sourceType) {
//			
//		}

		public void ForceUpdatePathData (IPathData data)
		{
			if (/*data.GetPath () != this ||*/ !(data is AbstractPathData)) {
				throw new ArgumentException ("Can't update foreign PathData: " + data);
			}
			((AbstractPathData)data).ForceUpdatePathPoints ();
		}



		// TODO how to clean up references???
		public int GetReferentCount ()
		{
			return referents.Count;
		}

		public UnityEngine.Object GetReferent (int index)
		{
			return referents [index];
		}

		public void SetReferent (int index, UnityEngine.Object obj)
		{
			referents [index] = obj;
		}

		public int AddReferent (UnityEngine.Object obj)
		{
			referents.Add (obj);
			return referents.Count - 1;
		}

		public void RemoveReferent (int index)
		{
			referents.RemoveAt (index);
		}

//		public bool PointsDirty {
//			get {
//				return pathPointsDirty;
//			}
//		}

		public bool Frozen {
			get {
				return this.frozenStatus == PathStatus.Frozen;
			}
		}

		public PathStatus FrozenStatus {
			set {
				this.frozenStatus = value;
			}
			get {
				return this.frozenStatus;
			}
		}

		public ParameterStore EditorParameters {
			get {
				return new ParameterStore (this.parameterStore, "Editor.");
			}
		}

		private void FireChangedEvent ()
		{
			if (null != Changed) {
				Debug.Log ("FireChangedEvent: " + Changed.GetInvocationList ().Length);
				try {
					Changed (this, EventArgs.Empty);
				} catch (Exception e) {
					Debug.LogError ("Catched an exception from Changed event listener(s): " + e);
				}
			}
		}


//		protected virtual DefaultPathModifierContainer CreatePathModifierContainer ()
//		{
//			return CreatePathModifierContainer (null);
//		}
//		
//		protected DefaultPathModifierContainer CreatePathModifierContainer (DefaultPathModifierContainer.SetPathPointsDelegate setPathPointsFunc)
//		{
//			DefaultPathModifierContainer pmc = new DefaultPathModifierContainer (
//				GetPathInfo,
//				PathModifiersChanged,
//				PathPointsChanged,
//				DoGetPathPointsArray,
//				() => {
//				this.pathPointsDirty = true;},
//			setPathPointsFunc,
//			this, null);
//			
//			return pmc;
//		}


		public ParameterStore GetParameterStore ()
		{
			return parameterStore;
		}



		public void OnBeforeSerialize ()
		{
			parameterStore.OnBeforeSerialize ();
			// TODO should we call OnBeforeSerialize() for all data sets here?
			OnBeforePathSerialize ();
		}
		public virtual void OnBeforePathSerialize ()
		{

		}
		public void OnAfterDeserialize ()
		{
			parameterStore.OnAfterDeserialize ();

			int dsCount = GetDataSetCount ();
			for (int i = 0; i < dsCount; i++) {
				IPathData d = GetDataSetAtIndex (i);

				AttachPathData (d);
			}


			// TODO Fire changed events? Do we know if anything was changed? Maybe not?
			OnAfterPathDeserialize ();

		}

//		protected abstract void OnAttachPathData (IPathData data);

		public virtual void OnAfterPathDeserialize ()
		{

		}

//
//
//		public void PathModifiersChanged ()
//		{
////			pathPointsDirty = true;
////			OnPathModifiersChanged ();
//
//			foreach (AbstractPathData d in dataSets) {
////				d.SetPath (this);
//				d.PathModifiersChanged ();
////				IPathModifierContainer pmc = d.GetPathModifierContainer ();
////				if (pmc is DefaultPathModifierContainer) {
////					((DefaultPathModifierContainer)pmc).SavePathModifiers (parameterStore);
////				}
//			}
//
//
//			FireChangedEvent ();
//
//		}

	


		void OnDrawGizmos ()
		{

			// Draw all data sets:
			int dsCount = GetDataSetCount ();
			for (int dsIndex = 0; dsIndex < dsCount; dsIndex++) {

				IPathData data = GetDataSetAtIndex (dsIndex);
				if (!data.IsDrawGizmos ()) {
					continue;
				}

				PathPoint[] pp = data.GetAllPoints ();


				//Vector3[] transformedPoints = new Vector3[pp.Length];


				// Draw the actual (final) path:
				Gizmos.color = data.GetColor ();//PathGizmoPrefs.FinalPathLineColor;
				for (int i = 1; i < pp.Length; i++) {
					Vector3 pt0 = transform.TransformPoint (pp [i - 1].Position);
					Vector3 pt1 = transform.TransformPoint (pp [i].Position);
					Gizmos.DrawLine (pt0, pt1);
				}

				// GetAllPoints() already returns the last point for loop, which is 
				// equal to the first point
				//			if (IsLoop () && pp.Length > 1) {
				//				// Connect last and first points:
				//				Vector3 pt0 = transform.TransformPoint (pp [0].Position);
				//				Vector3 pt1 = transform.TransformPoint (pp [pp.Length - 1].Position);
				//				Gizmos.DrawLine (pt0, pt1);
				//			}

				// Direction Vectors (Forward, Right and Up) and point markers
				Color upVectorColor = PathGizmoPrefs.UpVectorColor;
				Color dirVectorColor = PathGizmoPrefs.DirVectorColor;
				Color rightVectorColor = PathGizmoPrefs.RightVectorColor;

				Color pointMarkerColor = PathGizmoPrefs.FinalPathPointMarkerColor;
				Color firstPointMarkerColor = PathGizmoPrefs.FinalPathFirstPointMarkerColor;

				float upVectorLength = PathGizmoPrefs.UpVectorLength;
				float dirVectorLength = PathGizmoPrefs.DirVectorLength;
				float rightVectorLength = PathGizmoPrefs.RightVectorLength;

				float pointMarkerSize = PathGizmoPrefs.FinalPathPointMarkerSize;
				float firstPointMarkerSize = PathGizmoPrefs.FinalPathFirstPointMarkerSize;

				// TODO transform directions etc!
				for (int i = 0; i < pp.Length; i++) {
					Vector3 pt = transform.TransformPoint (pp [i].Position);

					Gizmos.color = (i == 0) ? firstPointMarkerColor : pointMarkerColor;
					Gizmos.DrawSphere (pt, (i == 0) ? firstPointMarkerSize : pointMarkerSize);
				}

				for (int i = 0; i < pp.Length; i++) {
					Vector3 pt = transform.TransformPoint (pp [i].Position);

					// Draw dir vector
					if (pp [i].HasDirection) {
						Gizmos.color = dirVectorColor;
						Gizmos.DrawLine (pt, pt + pp [i].Direction * dirVectorLength);
					}

					// Draw up vector
					if (pp [i].HasUp) {
						Gizmos.color = upVectorColor;
						Gizmos.DrawLine (pt, pt + pp [i].Up * upVectorLength);
					}

					// Draw ortho (right) vector
					if (pp [i].HasRight) { 
						Gizmos.color = rightVectorColor;
						Gizmos.DrawLine (pt, pt + pp [i].Right * rightVectorLength);
					}





				}
	            
	            
				//          // Draw handles
				//          
				//          for (int i = 0; i < pp.Length; i++) {
				//              float worldHandleSize = HandleUtility.GetHandleSize(transformedPoints[i]);
				//              float handleSize, pickSize;
				//              
				//              handleSize = Constants.controlPointHandleSize * worldHandleSize;
				//              pickSize = Constants.controlPointPickSize * worldHandleSize;
				//              
				//              Handles.Button(transformedPoints[i], transform.rotation, 
				//                             handleSize, pickSize, 
				//                             Handles.DotCap);
				//              
				//          }
			}
		}
	}


}
